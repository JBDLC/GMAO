{% extends "base.html" %}
{% block title %}Nouveau rapport{% endblock %}
{% block content %}
<style>
  .page-header {
    margin-top: 2rem;
    margin-bottom: 2rem;
  }
  .page-title {
    color: #1a3b50;
    font-weight: 700;
    font-size: 2rem;
    letter-spacing: -0.5px;
    margin: 0;
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .page-title::before {
    content: '';
    width: 4px;
    height: 32px;
    background: linear-gradient(135deg, #1a3b50 0%, #03192f 100%);
    border-radius: 2px;
  }
  .form-card {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    padding: 2rem;
    margin-bottom: 2rem;
  }
  .form-label {
    color: #1a3b50;
    font-weight: 600;
    margin-bottom: 0.5rem;
  }
  .form-control, .form-select {
    border: 1px solid #ced4da;
    border-radius: 4px;
    padding: 0.5rem 0.75rem;
    transition: all 0.2s;
  }
  .form-control:focus, .form-select:focus {
    border-color: #1a3b50;
    box-shadow: 0 0 0 0.25rem rgba(26, 59, 80, 0.25);
    outline: none;
  }
  .component-row {
    background: #f8f9fa;
    padding: 0.75rem;
    border-radius: 4px;
    margin-bottom: 0.5rem;
    border-left: 3px solid #1a3b50;
  }
  .btn-success {
    background-color: #1a3b50;
    border-color: #1a3b50;
    color: white;
    font-weight: 600;
    padding: 0.5rem 1.5rem;
    border-radius: 4px;
    transition: all 0.2s;
  }
  .btn-success:hover {
    background-color: #03192f;
    border-color: #03192f;
    color: white;
  }
  .btn-outline-secondary {
    border-color: #1a3b50;
    color: #1a3b50;
    font-weight: 500;
  }
  .btn-outline-secondary:hover {
    background-color: #1a3b50;
    border-color: #1a3b50;
    color: white;
  }
  .btn-outline-danger {
    border-color: #dc3545;
    color: #dc3545;
  }
  .btn-outline-danger:hover {
    background-color: #dc3545;
    color: white;
  }
  hr {
    border-color: #e0e0e0;
    margin: 1.5rem 0;
  }
  h4 {
    color: #1a3b50;
    font-weight: 600;
    margin-bottom: 1rem;
  }
  
  /* Responsive */
  @media (max-width: 768px) {
    .form-card {
      padding: 1.25rem;
    }
    
    .row.g-3 > [class*="col-"] {
      margin-bottom: 1rem;
    }
    
    .btn-success, .btn-outline-secondary {
      width: 100%;
      margin-bottom: 0.5rem;
    }
    
    .component-row {
      padding: 0.5rem;
    }
    
    .component-row .row > [class*="col-"] {
      margin-bottom: 0.5rem;
    }
  }
  
  @media (max-width: 576px) {
    .form-card {
      padding: 1rem;
    }
    
    .row.g-3 > [class*="col-"],
    .component-row .row > [class*="col-"] {
      flex: 0 0 100%;
      max-width: 100%;
    }
  }
</style>

<div class="page-header">
  <h1 class="page-title">{% if report %}Modifier{% else %}Créer{% endif %} un modèle de maintenance préventive</h1>
</div>

<div class="form-card">
<form method="post" id="maintenanceForm" action="{% if report %}{{ url_for('edit_maintenance', report_id=report.id) }}{% else %}{{ url_for('new_maintenance') }}{% endif %}">
  <div class="mb-3">
    <label class="form-label">Machine</label>
    <select class="form-select" name="machine_id" id="machineSelect" {% if report %}disabled{% else %}required{% endif %}>
      <option value="">Sélectionnez une machine...</option>
      {% for machine in machines %}
      <option value="{{ machine.id }}" {% if selected_machine_id == machine.id %}selected{% endif %}>
        {{ machine.name }} ({{ machine.code }})
      </option>
      {% endfor %}
    </select>
    {% if report %}
    <small class="form-text text-muted">La machine ne peut pas être modifiée pour un plan existant.</small>
    {% endif %}
  </div>
  <div class="mb-3 d-none" id="counterSelectContainer">
    <label class="form-label">Compteur(s) de référence pour la périodicité <span class="text-danger" id="counterRequired">*</span></label>
    <div id="countersList" style="max-height: 200px; overflow-y: auto; border: 1px solid #ced4da; border-radius: 4px; padding: 0.5rem;">
      <!-- Les compteurs seront ajoutés ici dynamiquement -->
    </div>
    <small class="form-text text-muted">Sélectionnez un ou plusieurs compteurs. La maintenance sera déclenchée lorsque le premier compteur atteint sa périodicité.</small>
  </div>
  <div class="mb-3">
    <label class="form-label">Nom du rapport</label>
    <input class="form-control" name="name" value="{% if report %}{{ report.name }}{% endif %}" required />
  </div>
  <div class="mb-3">
    <label class="form-label">Type de déclenchement</label>
    <select class="form-select" name="trigger_type" id="triggerTypeSelect" required>
      <option value="counter" {% if report and report.trigger_type == 'counter' %}selected{% endif %}>Compteur</option>
      <option value="calendar" {% if report and report.trigger_type == 'calendar' %}selected{% endif %}>Calendaire</option>
    </select>
    <small class="form-text text-muted">Choisissez si la maintenance est déclenchée par un compteur ou par un calendrier (tous les X jours).</small>
  </div>
  <div class="mb-3" id="calendarFields" style="display: {% if report and report.trigger_type == 'calendar' %}block{% else %}none{% endif %};">
    <label class="form-label">Date de début du calendrier</label>
    <input class="form-control" type="date" name="calendar_start_date" id="calendarStartDate" value="{% if report and report.calendar_start_date %}{{ report.calendar_start_date.strftime('%Y-%m-%d') }}{% endif %}" />
    <small class="form-text text-muted">La première maintenance sera due à cette date + la périodicité.</small>
  </div>
  <div class="mb-3">
    <label class="form-label">Périodicité</label>
    <div class="input-group">
      <input class="form-control" type="number" min="1" name="periodicity" value="{% if report %}{{ report.periodicity }}{% endif %}" required />
      <span class="input-group-text" id="periodicityUnit">{% if report and report.trigger_type == 'calendar' %}jours{% else %}h{% endif %}</span>
    </div>
    <small class="form-text text-muted" id="periodicityHelp">
      {% if report and report.trigger_type == 'calendar' %}
      La maintenance sera due tous les X jours à partir de la date de début.
      {% else %}
      La maintenance sera due tous les X heures de compteur.
      {% endif %}
    </small>
    <div id="unitWarning" class="alert alert-warning mt-2" style="display: none;">
      <small><strong>Attention :</strong> Tous les compteurs sélectionnés doivent avoir la même unité.</small>
    </div>
  </div>
  <hr />
  <h4>Éléments du rapport</h4>
  {% if all_reports %}
  <div class="mb-3">
    <label class="form-label">Charger depuis un modèle existant (optionnel)</label>
    <select class="form-select" id="loadFromTemplate" onchange="loadTemplateComponents(this.value)">
      <option value="">Sélectionner un modèle pour pré-remplir les éléments...</option>
      {% for report in all_reports %}
      <option value="{{ report.id }}">{{ report.name }} ({{ report.machine.name }})</option>
      {% endfor %}
    </select>
    <small class="form-text text-muted">Sélectionnez un modèle existant pour pré-remplir les éléments. Vous pourrez ensuite les modifier ou en ajouter d'autres.</small>
  </div>
  {% endif %}
  <div id="componentRows">
    {% if report and report.components %}
      {% for component in report.components %}
      <div class="row g-2 mb-2 component-row">
        <div class="col-md-4">
          <input class="form-control" name="component_label" placeholder="Intitulé" value="{{ component.label }}" required />
        </div>
        <div class="col-md-4">
          <input class="form-control" name="component_comment" placeholder="Commentaire (optionnel)" value="{{ component.comment or '' }}" />
        </div>
        <div class="col-md-3">
          <select class="form-select" name="component_type" required>
            <option value="">Type...</option>
            <option value="number" {% if component.field_type == 'number' %}selected{% endif %}>Nombre</option>
            <option value="text" {% if component.field_type == 'text' %}selected{% endif %}>Texte</option>
            <option value="checkbox" {% if component.field_type == 'checkbox' %}selected{% endif %}>Tick box</option>
          </select>
        </div>
        <div class="col-md-1 d-flex align-items-center">
          <button type="button" class="btn btn-outline-danger btn-sm btn-remove-component" title="Supprimer cet élément">
            <img src="{{ url_for('static', filename='icons/delete.svg') }}" alt="Supprimer" style="width: 16px; height: 16px; display: inline-block; vertical-align: middle;">
          </button>
        </div>
      </div>
      {% endfor %}
    {% else %}
    <div class="row g-2 mb-2 component-row">
      <div class="col-md-4">
        <input class="form-control" name="component_label" placeholder="Intitulé" required />
      </div>
      <div class="col-md-4">
        <input class="form-control" name="component_comment" placeholder="Commentaire (optionnel)" />
      </div>
      <div class="col-md-3">
        <select class="form-select" name="component_type" required>
          <option value="">Type...</option>
          <option value="number">Nombre</option>
          <option value="text">Texte</option>
          <option value="checkbox">Tick box</option>
        </select>
      </div>
      <div class="col-md-1 d-flex align-items-center">
        <button type="button" class="btn btn-outline-danger btn-sm btn-remove-component" title="Supprimer cet élément">
          <img src="{{ url_for('static', filename='icons/delete.svg') }}" alt="Supprimer" style="width: 16px; height: 16px; display: inline-block; vertical-align: middle;">
        </button>
      </div>
    </div>
    {% endif %}
  </div>
  <button class="btn btn-outline-secondary btn-sm mb-3" type="button" id="addComponent">+ Élément</button>
  <div class="mt-4">
    <button class="btn btn-success">Enregistrer</button>
  </div>
</form>
</div>
{% endblock %}
{% block scripts %}
<script>
  const rows = document.getElementById("componentRows");
  const addComponentBtn = document.getElementById("addComponent");

  addComponentBtn.addEventListener("click", () => {
    const template = rows.querySelector(".component-row");
    const clone = template.cloneNode(true);
    // Réinitialiser les valeurs des champs du clone
    clone.querySelectorAll("input, select").forEach((el) => {
      if (el.type === "checkbox") {
        el.checked = false;
      } else {
        el.value = "";
      }
    });
    rows.appendChild(clone);
  });

  // Suppression d'un élément du rapport
  rows.addEventListener("click", (event) => {
    const target = event.target;
    if (target.closest(".btn-remove-component")) {
      const row = target.closest(".component-row");
      const allRows = rows.querySelectorAll(".component-row");
      if (allRows.length > 1) {
        row.remove();
      } else {
        // S'il ne reste qu'une ligne, on la vide simplement
        row.querySelectorAll("input, select").forEach((el) => (el.value = ""));
      }
    }
  });
  
  // Gestion de l'affichage du sélecteur de compteur
  const machineSelect = document.getElementById("machineSelect");
  const counterSelectContainer = document.getElementById("counterSelectContainer");
  const counterSelect = document.getElementById("counterSelect");
  
  async function updateCounterSelect() {
    const machineId = machineSelect.value;
    const countersList = document.getElementById("countersList");
    
    if (!machineId) {
      counterSelectContainer.classList.add("d-none");
      countersList.innerHTML = "";
      document.getElementById("counterRequired").style.display = "none";
      return;
    }
    
    try {
      const response = await fetch(`/api/machine/${machineId}/available-counters`);
      const data = await response.json();
      const counters = data.counters;
      
      if (counters && counters.length > 0) {
        counterSelectContainer.classList.remove("d-none");
        countersList.innerHTML = "";
        
        // Vérifier si la machine a son propre compteur
        const hasMachineCounter = counters.some(c => c.type === "machine");
        
        counters.forEach(counter => {
          const div = document.createElement("div");
          div.className = "form-check mb-2";
          
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "form-check-input counter-checkbox";
          checkbox.name = "counter_ids[]";
          checkbox.value = counter.id === null ? "machine" : counter.id;
          checkbox.id = `counter_${counter.id === null ? "machine" : counter.id}`;
          checkbox.dataset.unit = counter.unit || 'h'; // Stocker l'unité dans le dataset
          
          // Pré-cocher si on est en mode édition et que ce compteur est sélectionné
          {% if report and selected_counter_ids %}
          const counterValue = counter.id === null ? null : counter.id;
          {% for selected_id in selected_counter_ids %}
          if (counterValue === {% if selected_id is none %}null{% else %}{{ selected_id }}{% endif %}) {
            checkbox.checked = true;
          }
          {% endfor %}
          {% endif %}
          
          const label = document.createElement("label");
          label.className = "form-check-label";
          label.htmlFor = checkbox.id;
          label.textContent = counter.name + ` (${counter.value} ${counter.unit})`;
          
          div.appendChild(checkbox);
          div.appendChild(label);
          countersList.appendChild(div);
        });
        
        // Ajouter les event listeners pour valider les unités
        updateUnitValidation();
        
        // Si la machine n'a pas de compteur, au moins un compteur est obligatoire
        if (!hasMachineCounter) {
          document.getElementById("counterRequired").style.display = "inline";
        } else {
          document.getElementById("counterRequired").style.display = "none";
        }
      } else {
        counterSelectContainer.classList.add("d-none");
        countersList.innerHTML = '<div class="text-muted">Aucun compteur disponible</div>';
        document.getElementById("counterRequired").style.display = "none";
      }
    } catch (error) {
      console.error("Erreur lors de la récupération des compteurs:", error);
      counterSelectContainer.classList.add("d-none");
      document.getElementById("counterRequired").style.display = "none";
    }
  }
  
  // Fonction pour mettre à jour l'unité de périodicité et valider les unités
  function updateUnitValidation() {
    const checked = document.querySelectorAll('.counter-checkbox:checked');
    const periodicityUnit = document.getElementById("periodicityUnit");
    const unitWarning = document.getElementById("unitWarning");
    
    if (checked.length === 0) {
      periodicityUnit.textContent = "h";
      unitWarning.style.display = "none";
      return;
    }
    
    // Vérifier que tous les compteurs sélectionnés ont la même unité
    const units = Array.from(checked).map(cb => cb.dataset.unit || 'h');
    const uniqueUnits = [...new Set(units)];
    
    if (uniqueUnits.length > 1) {
      // Unités différentes : afficher un avertissement et désélectionner les autres
      unitWarning.style.display = "block";
      // Désélectionner tous sauf le premier
      for (let i = 1; i < checked.length; i++) {
        checked[i].checked = false;
      }
      // Re-vérifier avec seulement le premier
      const firstChecked = document.querySelector('.counter-checkbox:checked');
      if (firstChecked) {
        periodicityUnit.textContent = firstChecked.dataset.unit || 'h';
      }
    } else {
      // Toutes les unités sont identiques
      unitWarning.style.display = "none";
      periodicityUnit.textContent = uniqueUnits[0] || 'h';
    }
  }
  
  // Ajouter les event listeners pour les checkboxes de compteurs
  document.addEventListener('change', function(e) {
    if (e.target.classList.contains('counter-checkbox')) {
      updateUnitValidation();
    }
  });
  
  // Validation : au moins un compteur doit être sélectionné si requis et unités identiques
  document.getElementById("maintenanceForm").addEventListener("submit", function(e) {
    const triggerType = document.getElementById("triggerTypeSelect").value;
    
    if (triggerType === "counter") {
      const counterRequired = document.getElementById("counterRequired").style.display !== "none";
      if (counterRequired) {
        const checked = document.querySelectorAll('.counter-checkbox:checked');
        if (checked.length === 0) {
          e.preventDefault();
          alert("Veuillez sélectionner au moins un compteur.");
          return false;
        }
        
        // Vérifier que tous les compteurs ont la même unité
        const units = Array.from(checked).map(cb => cb.dataset.unit || 'h');
        const uniqueUnits = [...new Set(units)];
        if (uniqueUnits.length > 1) {
          e.preventDefault();
          alert("Tous les compteurs sélectionnés doivent avoir la même unité.");
          return false;
        }
      }
    }
    return true;
  });
  
  machineSelect.addEventListener("change", updateCounterSelect);
  
  // Initialiser au chargement si une machine est déjà sélectionnée
  if (machineSelect.value) {
    updateCounterSelect();
  }
  
  // Gestion du type de déclenchement (compteur vs calendaire)
  const triggerTypeSelect = document.getElementById("triggerTypeSelect");
  const calendarFields = document.getElementById("calendarFields");
  const calendarStartDate = document.getElementById("calendarStartDate");
  const periodicityUnit = document.getElementById("periodicityUnit");
  const periodicityHelp = document.getElementById("periodicityHelp");
  
  function updateTriggerTypeFields() {
    const triggerType = triggerTypeSelect.value;
    
    if (triggerType === "calendar") {
      calendarFields.style.display = "block";
      calendarStartDate.required = true;
      counterSelectContainer.classList.add("d-none");
      periodicityUnit.textContent = "jours";
      periodicityHelp.textContent = "La maintenance sera due tous les X jours à partir de la date de début.";
    } else {
      calendarFields.style.display = "none";
      calendarStartDate.required = false;
      periodicityUnit.textContent = "heures";
      periodicityHelp.textContent = "La maintenance sera due tous les X heures de compteur.";
      
      // Afficher les compteurs si une machine est sélectionnée
      if (machineSelect.value) {
        updateCounterSelect();
      }
    }
  }
  
  triggerTypeSelect.addEventListener("change", updateTriggerTypeFields);
  
  // Initialiser au chargement
  updateTriggerTypeFields();
  
  // Fonction pour charger les composants d'un modèle existant
  async function loadTemplateComponents(reportId) {
    if (!reportId) return;
    
    try {
      const response = await fetch(`/api/maintenance-report/${reportId}/components`);
      const data = await response.json();
      
      if (data.success && data.components && data.components.length > 0) {
        // Vider les lignes existantes sauf la première
        const componentRows = document.getElementById("componentRows");
        const existingRows = componentRows.querySelectorAll(".component-row");
        existingRows.forEach((row, index) => {
          if (index > 0) {
            row.remove();
          } else {
            // Vider la première ligne
            row.querySelectorAll("input, select").forEach((el) => (el.value = ""));
          }
        });
        
        // Ajouter les composants du modèle
        data.components.forEach((component, index) => {
          let row;
          if (index === 0) {
            // Utiliser la première ligne existante
            row = componentRows.querySelector(".component-row");
          } else {
            // Cloner la première ligne pour les autres
            const template = componentRows.querySelector(".component-row");
            row = template.cloneNode(true);
            componentRows.appendChild(row);
          }
          
          // Remplir les champs
          const labelInput = row.querySelector('input[name="component_label"]');
          const commentInput = row.querySelector('input[name="component_comment"]');
          const typeSelect = row.querySelector('select[name="component_type"]');
          
          if (labelInput) labelInput.value = component.label || "";
          if (commentInput) commentInput.value = component.comment || "";
          if (typeSelect) typeSelect.value = component.field_type || "";
        });
      }
    } catch (error) {
      console.error("Erreur lors du chargement du modèle:", error);
      alert("Erreur lors du chargement du modèle");
    }
  }
  
  // Exposer la fonction globalement
  window.loadTemplateComponents = loadTemplateComponents;
</script>
{% endblock %}


          label.htmlFor = checkbox.id;
          label.textContent = counter.name + ` (${counter.value} ${counter.unit})`;
          
          div.appendChild(checkbox);
          div.appendChild(label);
          countersList.appendChild(div);
        });
        
        // Ajouter les event listeners pour valider les unités
        updateUnitValidation();
        
        // Si la machine n'a pas de compteur, au moins un compteur est obligatoire
        if (!hasMachineCounter) {
          document.getElementById("counterRequired").style.display = "inline";
        } else {
          document.getElementById("counterRequired").style.display = "none";
        }
      } else {
        counterSelectContainer.classList.add("d-none");
        countersList.innerHTML = '<div class="text-muted">Aucun compteur disponible</div>';
        document.getElementById("counterRequired").style.display = "none";
      }
    } catch (error) {
      console.error("Erreur lors de la récupération des compteurs:", error);
      counterSelectContainer.classList.add("d-none");
      document.getElementById("counterRequired").style.display = "none";
    }
  }
  
  // Fonction pour mettre à jour l'unité de périodicité et valider les unités
  function updateUnitValidation() {
    const checked = document.querySelectorAll('.counter-checkbox:checked');
    const periodicityUnit = document.getElementById("periodicityUnit");
    const unitWarning = document.getElementById("unitWarning");
    
    if (checked.length === 0) {
      periodicityUnit.textContent = "h";
      unitWarning.style.display = "none";
      return;
    }
    
    // Vérifier que tous les compteurs sélectionnés ont la même unité
    const units = Array.from(checked).map(cb => cb.dataset.unit || 'h');
    const uniqueUnits = [...new Set(units)];
    
    if (uniqueUnits.length > 1) {
      // Unités différentes : afficher un avertissement et désélectionner les autres
      unitWarning.style.display = "block";
      // Désélectionner tous sauf le premier
      for (let i = 1; i < checked.length; i++) {
        checked[i].checked = false;
      }
      // Re-vérifier avec seulement le premier
      const firstChecked = document.querySelector('.counter-checkbox:checked');
      if (firstChecked) {
        periodicityUnit.textContent = firstChecked.dataset.unit || 'h';
      }
    } else {
      // Toutes les unités sont identiques
      unitWarning.style.display = "none";
      periodicityUnit.textContent = uniqueUnits[0] || 'h';
    }
  }
  
  // Ajouter les event listeners pour les checkboxes de compteurs
  document.addEventListener('change', function(e) {
    if (e.target.classList.contains('counter-checkbox')) {
      updateUnitValidation();
    }
  });
  
  // Validation : au moins un compteur doit être sélectionné si requis et unités identiques
  document.getElementById("maintenanceForm").addEventListener("submit", function(e) {
    const triggerType = document.getElementById("triggerTypeSelect").value;
    
    if (triggerType === "counter") {
      const counterRequired = document.getElementById("counterRequired").style.display !== "none";
      if (counterRequired) {
        const checked = document.querySelectorAll('.counter-checkbox:checked');
        if (checked.length === 0) {
          e.preventDefault();
          alert("Veuillez sélectionner au moins un compteur.");
          return false;
        }
        
        // Vérifier que tous les compteurs ont la même unité
        const units = Array.from(checked).map(cb => cb.dataset.unit || 'h');
        const uniqueUnits = [...new Set(units)];
        if (uniqueUnits.length > 1) {
          e.preventDefault();
          alert("Tous les compteurs sélectionnés doivent avoir la même unité.");
          return false;
        }
      }
    }
    return true;
  });
  
  machineSelect.addEventListener("change", updateCounterSelect);
  
  // Initialiser au chargement si une machine est déjà sélectionnée
  if (machineSelect.value) {
    updateCounterSelect();
  }
  
  // Gestion du type de déclenchement (compteur vs calendaire)
  const triggerTypeSelect = document.getElementById("triggerTypeSelect");
  const calendarFields = document.getElementById("calendarFields");
  const calendarStartDate = document.getElementById("calendarStartDate");
  const periodicityUnit = document.getElementById("periodicityUnit");
  const periodicityHelp = document.getElementById("periodicityHelp");
  
  function updateTriggerTypeFields() {
    const triggerType = triggerTypeSelect.value;
    
    if (triggerType === "calendar") {
      calendarFields.style.display = "block";
      calendarStartDate.required = true;
      counterSelectContainer.classList.add("d-none");
      periodicityUnit.textContent = "jours";
      periodicityHelp.textContent = "La maintenance sera due tous les X jours à partir de la date de début.";
    } else {
      calendarFields.style.display = "none";
      calendarStartDate.required = false;
      periodicityUnit.textContent = "heures";
      periodicityHelp.textContent = "La maintenance sera due tous les X heures de compteur.";
      
      // Afficher les compteurs si une machine est sélectionnée
      if (machineSelect.value) {
        updateCounterSelect();
      }
    }
  }
  
  triggerTypeSelect.addEventListener("change", updateTriggerTypeFields);
  
  // Initialiser au chargement
  updateTriggerTypeFields();
  
  // Fonction pour charger les composants d'un modèle existant
  async function loadTemplateComponents(reportId) {
    if (!reportId) return;
    
    try {
      const response = await fetch(`/api/maintenance-report/${reportId}/components`);
      const data = await response.json();
      
      if (data.success && data.components && data.components.length > 0) {
        // Vider les lignes existantes sauf la première
        const componentRows = document.getElementById("componentRows");
        const existingRows = componentRows.querySelectorAll(".component-row");
        existingRows.forEach((row, index) => {
          if (index > 0) {
            row.remove();
          } else {
            // Vider la première ligne
            row.querySelectorAll("input, select").forEach((el) => (el.value = ""));
          }
        });
        
        // Ajouter les composants du modèle
        data.components.forEach((component, index) => {
          let row;
          if (index === 0) {
            // Utiliser la première ligne existante
            row = componentRows.querySelector(".component-row");
          } else {
            // Cloner la première ligne pour les autres
            const template = componentRows.querySelector(".component-row");
            row = template.cloneNode(true);
            componentRows.appendChild(row);
          }
          
          // Remplir les champs
          const labelInput = row.querySelector('input[name="component_label"]');
          const commentInput = row.querySelector('input[name="component_comment"]');
          const typeSelect = row.querySelector('select[name="component_type"]');
          
          if (labelInput) labelInput.value = component.label || "";
          if (commentInput) commentInput.value = component.comment || "";
          if (typeSelect) typeSelect.value = component.field_type || "";
        });
      }
    } catch (error) {
      console.error("Erreur lors du chargement du modèle:", error);
      alert("Erreur lors du chargement du modèle");
    }
  }
  
  // Exposer la fonction globalement
  window.loadTemplateComponents = loadTemplateComponents;
</script>
{% endblock %}

